---
title: "Megan's code for Isoviz"
output: html_notebook
---


# 230327
Write a function that maps leafcutter cluster data back to isoforms 
- use psl/gtf, advantage of psl is it is compatible with long read generated gtf which lacks UTR info, it will likely become increasingly common to use long read data to determine which isoforms are present in a specific cell type
- input gene name and cell type, start with RBFOX2 and A375
- output is clusters with counts and linked isoforms
- print image filtered for cluster with <=4 junctions but print pdf with all
- if junctions doesn't map back, have a parameter to include/not include as novel
- go back and only plot isoforms with junction supporting data
- eventually also want to call Andrews predictions and get best predicted guide for junction
- could we even have a screen design setting? to scale it up?
- also, can use the code and plots to quantify knockdown
- need to control for library size- tpm of gene?

```{r}
# libraries
require(readr)
require(dplyr)
require(tidyr)
require(magrittr)
require(ggplot2)
require(data.table)
require(stringr)
require(ggpubr)
require(grid)
require(gridExtra)
require(cowplot)

```

Raw data -> Data for package
Leafcutter clusters
Run this on publicly available data for major cell types
But have function for people to read in their on bam file

Defining Intron clustering with Leafcutter
make a text file with the name of all bed files

# more stringent- better for calling unique clusters
python ~/Downloads/leafcutter/clustering/leafcutter_cluster_regtools.py -j a375_screen_cells_for_lfc.txt -m 30 -p 0.1 -o a375_screen_cells -l 500000 --includeconst --checkchrom

# less stringent (-m 5) which is better for detecting all singletons
python ~/Downloads/leafcutter/clustering/leafcutter_cluster_regtools.py -j a375_screen_cells_for_lfc.txt -m 5 -p 0.1 -o a375_screen_cells_5reads -l 500000 --includeconst --checkchrom

output is a text file
-p MINCLURATIO, --mincluratio=MINCLURATIO
                        minimum fraction of reads in a cluster that support a
                        junction (default 0.001)
                        
--includeconst
```{r}
# This is data from our A375 screen cells and is the most accurate for our work
# now this includes constitutive exons which have a single junction per cluster
# required 30 total reads per cluster and junction to be 10% of total
clusters <- read_tsv("~/isoviz/data-raw/a375_screen_cells_perind.constcounts.gz", col_names = FALSE, skip = 1) # 59,783
clusters %<>% 
  separate(X1, into = c("coords", "counts"), sep = " ") %>% 
  separate(counts, into = c("junc.counts", "cluster.counts"), sep = "/", convert = TRUE) %>%
  separate(coords, into = c("chr", "start", "end", "name"), sep = ":", convert = TRUE) %>% 
  separate(name, into = c("same", "cluster.n", "extra"), sep = "_") %>% 
  select(-same, -extra)

# remove clusters with no counts
# filter out chrM and chrY clusters
clusters %<>% filter(cluster.counts > 0, chr != "chrY", chr != "chrM") # 15,886

clusters_table = as.data.table(clusters)
save(clusters_table, file = "~/isoviz/data/A375_lfc_clusters.rda")


# HEK293 cells- our data
clusters <- read_tsv("~/isoviz/data-raw/HEK-NFYA-rep2-empty_perind.constcounts.gz", col_names = FALSE, skip = 1) # 46,102
clusters %<>% 
  separate(X1, into = c("coords", "counts"), sep = " ") %>% 
  separate(counts, into = c("junc.counts", "cluster.counts"), sep = "/", convert = TRUE) %>%
  separate(coords, into = c("chr", "start", "end", "name"), sep = ":", convert = TRUE) %>% 
  separate(name, into = c("same", "cluster.n", "extra"), sep = "_") %>% 
  select(-same, -extra)

# remove clusters with no counts
# filter out chrM and chrY clusters
clusters %<>% filter(cluster.counts > 0, chr != "chrY", chr != "chrM")
clusters_table = as.data.table(clusters)
save(clusters_table, file = "~/isoviz/data/HEK293_lfc_clusters.rda")

# 35738736-36028824
singletons <- read_tsv("~/knowles_lab/Megan/230320_cas13_validation/junctions/HEK-NFYA-rep2-empty_singletons_perind.constcounts.gz", col_names = FALSE, skip = 1)
singletons %<>% 
  separate(X1, into = c("coords", "counts"), sep = " ") %>% 
  separate(counts, into = c("junc.counts", "cluster.counts"), sep = "/", convert = TRUE) %>%
  separate(coords, into = c("chr", "start", "end", "name"), sep = ":", convert = TRUE) %>% 
  separate(name, into = c("same", "cluster.n", "extra"), sep = "_") %>% 
  select(-same, -extra)

singletons %>% filter(chr == "chr22", start >= 35738736, end <= 36028824)


# hESC- our data
clusters <- read_tsv("~/isoviz/data-raw/21c_hESC_RB2_empty_perind.constcounts.gz", col_names = FALSE, skip = 1)
clusters %<>% 
  separate(X1, into = c("coords", "counts"), sep = " ") %>% 
  separate(counts, into = c("junc.counts", "cluster.counts"), sep = "/", convert = TRUE) %>%
  separate(coords, into = c("chr", "start", "end", "name"), sep = ":", convert = TRUE) %>% 
  separate(name, into = c("same", "cluster.n", "extra"), sep = "_") %>% 
  select(-same, -extra)

# remove clusters with no counts
# filter out chrM and chrY clusters
clusters %<>% filter(cluster.counts > 0, chr != "chrY", chr != "chrM")
clusters_table = as.data.table(clusters)
save(clusters_table, file = "~/isoviz/data/hESC_lfc_clusters.rda")


```

Raw data -> Data for package
Gene/transcript name conversion file
Others might want to do this for a different gtf version
```{r}
# could make this a function
# create gene name conversion file from gtf

gtf_convert = function(gtf_file){
  gtf = read_tsv(gtf_file, col_names = FALSE, skip = 5) %>% filter(X3 == "transcript")

  gtf$transcript_id = sapply(strsplit(as.character(gtf$X9), ";"), function(x) x[[2]])
  gtf$transcript_id = sapply(gtf$transcript_id, gsub, pattern = "transcript_id", replacement = "")
  gtf$transcript_id = sapply(as.character(gtf$transcript_id), gsub, pattern = '"', replacement = '')
  gtf$transcript_id = sapply(as.character(gtf$transcript_id), gsub, pattern = ' ', replacement = '')

  gtf$gene_id = sapply(strsplit(as.character(gtf$X9), ";"), function(x) x[[1]])
  gtf$gene_id = sapply(gtf$gene_id, gsub, pattern = "gene_id", replacement = "")
  gtf$gene_id = sapply(as.character(gtf$gene_id), gsub, pattern = '"', replacement = '')
  gtf$gene_id = sapply(as.character(gtf$gene_id), gsub, pattern = ' ', replacement = '')

  gtf$transcript_name = sapply(strsplit(as.character(gtf$X9), ";"), function(x) x[[6]])
  gtf$transcript_name = sapply(gtf$transcript_name, gsub, pattern = "transcript_name", replacement = "")
  gtf$transcript_name = sapply(as.character(gtf$transcript_name), gsub, pattern = '"', replacement = '')
  gtf$transcript_name = sapply(as.character(gtf$transcript_name), gsub, pattern = ' ', replacement = '')

  gtf$gene_name = sapply(strsplit(as.character(gtf$X9), ";"), function(x) x[[4]])
  gtf$gene_name = sapply(gtf$gene_name, gsub, pattern = "gene_name", replacement = "")
  gtf$gene_name = sapply(as.character(gtf$gene_name), gsub, pattern = '"', replacement = '')
  gtf$gene_name = sapply(as.character(gtf$gene_name), gsub, pattern = ' ', replacement = '')

  gtf$gene_type = sapply(strsplit(as.character(gtf$X9), ";"), function(x) x[[3]])
  gtf$gene_type = sapply(gtf$gene_type, gsub, pattern = "gene_type", replacement = "")
  gtf$gene_type = sapply(as.character(gtf$gene_type), gsub, pattern = '"', replacement = '')
  gtf$gene_type = sapply(as.character(gtf$gene_type), gsub, pattern = ' ', replacement = '')

  gtf$transcript_type = sapply(strsplit(as.character(gtf$X9), ";"), function(x) x[[5]])
  gtf$transcript_type = sapply(gtf$transcript_type, gsub, pattern = "transcript_type", replacement = "")
  gtf$transcript_type = sapply(as.character(gtf$transcript_type), gsub, pattern = '"', replacement = '')
  gtf$transcript_type = sapply(as.character(gtf$transcript_type), gsub, pattern = ' ', replacement = '')

  gtf %<>% dplyr::select(gene_id, trans_id = transcript_id, gene_name, transcript_name, gene_type, transcript_type) %>%
    distinct()

}

output = gtf_convert("~/isoviz/data-raw/gencode.v41.basic.annotation.gtf")
write_tsv(output, "~/isoviz/data-raw/gencode_v41_gene-transcript-convert.txt", col_names = TRUE)

```


Add this to original genomedata.R script
```{r}
# modify psl file data to include other gene and transcript names
# currently using gencode basic anntotation file
convert = read_tsv("~/isoviz/data-raw/gencode_v41_gene-transcript-convert.txt", col_names = TRUE)

load("~/isoviz/data/iso_exon_data.rda") # 839,796
iso_data_complete = iso_exon_data %>% left_join(convert, by = c("gene_id", "trans_id"))

save(iso_data_complete, file = "~/isoviz/data/iso_data_complete.rda")

```

Write function to generate intron coords from exon coords- this is currently slow (~30 minutes), can we make the loop more efficient?
```{r}
# make psl with intron coords instead of exon
# adapted from genomedata.R

make_intron_coords = function(psl){
  
  mydataset <- fread(psl)

  mydataset$gene_id = sapply(mydataset$V10, function(x){strsplit(x, "_")[[1]][2]})
  mydataset$trans_id = sapply(mydataset$V10, function(x){strsplit(x, "_")[[1]][1]})

  # Get coordinates for each "block"
  mydataset$blocksizes = sapply(mydataset$V19, function(x){paste(strsplit(x, ",")[[1]], collapse=",")})
  mydataset$blockstarts = sapply(mydataset$V21, function(x){paste(strsplit(x, ",")[[1]], collapse=",")})
  mydataset$strand = mydataset$V9
  mydataset$chr = mydataset$V14
  mydataset$start = mydataset$V16
  mydataset$end = mydataset$V17
  mydataset$transcript_length = mydataset$end - mydataset$start

  # Clean up and seperate blocks into rows
  # need to do different adjustments here to get intron coords that will line up with leafcutter
  mydataset = mydataset %>% dplyr::select(chr, start, end, trans_id, gene_id,strand, blocksizes, blockstarts,
                            transcript_length) %>% separate_rows(blocksizes, blockstarts)
  mydataset$blockstarts=as.numeric(mydataset$blockstarts)
  mydataset$blocksizes=as.numeric(mydataset$blocksizes)
  mydataset$blockends = mydataset$blockstarts + mydataset$blocksizes

  transcript_ids = unique(mydataset$trans_id)
  length(transcript_ids) # 116,566
  trans_id = c()
  intron_starts = c()
  intron_ends = c()
  
  # this is the part that is slow
  for(id in transcript_ids){
    data = mydataset %>% filter(trans_id == id)
    new_ends = data$blockstarts[-1] + 1
    len = nrow(data)
    new_starts = data$blockends[-len]
    n = len-1
    trans_id = c(trans_id, rep(id, n))
    intron_starts = c(intron_starts, new_starts)
    intron_ends = c(intron_ends, new_ends)
  }

  # Important note: this no longer has single exon transcripts
  intron_data = data.frame(trans_id, intron_starts, intron_ends) # 723,230

  convert = read_tsv("~/isoviz/data-raw/gencode_v41_gene-transcript-convert.txt", col_names = TRUE)
  trans_info = mydataset %>% select(1, 4, 5, 6) %>% distinct() %>% filter(chr != "chrY", chr != "chrM") 

  data = intron_data %>% left_join(trans_info,  by = "trans_id") %>% 
    left_join(convert, by = c("gene_id", "trans_id")) %>% select(4, 2, 3, 5, 1, 6, 7, 8, 9, 10)

  iso_intron_data = as.data.table(data)

}

iso_intron_data = make_intron_coords("~/isoviz/data-raw/gencode.v41.basic.annotation.psl")
save(iso_intron_data, file = "~/isoviz/data/iso_intron_data.rda")

```

Function: Map junction to isoform
```{r}
load(file = "~/isoviz/data/iso_intron_data.rda")
#load(file = "~/isoviz/data/a375_screen_lfc_clusters.rda")
#load(file = "~/isoviz/data/HEK293_lfc_clusters.rda")

# is it better to load rda within a function?
# map junctions function- for now, it isn't using cell type but eventually we should change this
map_junction = function(gene = "ENSG00000001167.15", cell_type = "HEK293"){
  
  # filter for gene, for now, also filter for protein coding transcripts- can set this as a parameter later
  gene_iso_data = iso_intron_data %>% filter(grepl(gene, gene_id), transcript_type == "protein_coding") # 17 for NFYA
  
  # join iso data with leafcutter data and mark any unannotated junctions
  # consider cell type
  lfc_clusters = paste0(cell_type, "_lfc_clusters")
  load(file = paste0("~/isoviz/data/", lfc_clusters, ".rda"))
  const_junc_list = clusters_table %>% 
    group_by(cluster.n) %>% 
    tally() %>% filter(n == 1) %>% ungroup()
  clusters_table %<>% mutate(junc.type = ifelse(cluster.n %in% const_junc_list$cluster.n, "Common", "Unique"))
  gene_cluster = gene_iso_data %>% 
    left_join(clusters_table, by = c("chr", "intron_starts" = "start", "intron_ends" = "end")) %>%
    filter(!is.na(cluster.n))

  gene = unique(gene_cluster$gene_id)
  name = unique(gene_cluster$gene_name)
  gene_strand = unique(gene_cluster$strand)
  cluster_ids = unique(gene_cluster$cluster.n)
  
  output = clusters_table %>% filter(cluster.n %in% cluster_ids) %>% group_by(cluster.n) %>% mutate(junc.per.cluster = n()) %>% 
    left_join(gene_iso_data, by = c("chr", "start" = "intron_starts", "end" = "intron_ends")) %>% 
    mutate(junc.usage = round((junc.counts/cluster.counts)*100, digits = 0), 
           transcript_name = ifelse(is.na(transcript_name), paste0(cluster.n, "_Unannotated"), transcript_name),
           trans_id = ifelse(is.na(trans_id), paste0(cluster.n, "_Unannotated"), trans_id),
           gene_id = ifelse(is.na(gene_id), gene, gene_id),
           gene_name = ifelse(is.na(gene_name), name, gene_name),
           strand = ifelse(is.na(strand), gene_strand, strand), cell_line = paste0(cell_type))
  
  return(output)
}

to_plot = map_junction("ENSG00000001167.15") # NFYA
to_plot = map_junction("ENSG00000100320") # RBFOX2, alt start is missing because it's intron doesnt overlap another and counts are only 8 so included in consitutive either

# can we ask if all junctions of an isoform are represented to filter isoforms?
# can we create pseudo regtools output based on all possible junctions and run that through leafcutter to get true common versus unique

```

```{r}
load(file='~/isoviz/data/iso_data_complete.rda')
df = to_plot

# plot isoform plus leafcutter clusters
plot_junction_to_isoform = function(df, include_common_juncs = FALSE){
  
  # I am copying the plot_isoforms function here, figure out how to integrate these later
  gene = unique(df$gene_id)
  gene_trans =which(str_detect(iso_data_complete$gene_id, gene))
  gene_data = iso_data_complete[gene_trans,]
  
  # filter out common junctions for plotting (default)
  if(include_common_juncs == FALSE){
    df %<>% filter(junc.type == "Unique")
  }

  # get info
  name = unique(df$gene_name)
  transcripts = unique(df$transcript_name)
  
  # filter for transcripts that have junction level data to support
  gene_data %<>% filter(transcript_name %in% transcripts)

  # setting parameters for the plot based on length of the gene and number of isoforms
  length = max(gene_data$end) - min(gene_data$start)
  min_start = min(gene_data$start)
  n = gene_data %>% group_by(trans_id) %>% tally() %>% nrow()
  y_max = n + 1
  max_end = max(gene_data$end)

  # order the isoforms by length for plotting
  order_plot = gene_data %>% group_by(transcript_name, transcript_length) %>% tally() %>%
    dplyr::arrange(desc(transcript_length), desc(n))
  order_plot$trans_order = 1:nrow(order_plot)
  order_plot = order_plot %>% dplyr::select(transcript_name, trans_order)

  to_plot_ordered = gene_data %>% full_join(order_plot, by = c("transcript_name")) %>%
    arrange(trans_order, blockstarts) 
  to_plot_ordered = to_plot_ordered %>% mutate(seg_end = end)

  # make isoform plot
  p1 = ggplot() +
    geom_segment(aes(x = to_plot_ordered$start, y = to_plot_ordered$trans_order,
                     xend = to_plot_ordered$seg_end, yend = to_plot_ordered$trans_order)) +
    geom_rect(data = to_plot_ordered, mapping = aes(xmin = blockstarts, xmax = blockends, ymin = trans_order - 0.3, ymax = trans_order + 0.3)) +
    xlim(min_start, max_end) + ylim(0,y_max) +
    geom_text(aes(x = Inf, y = to_plot_ordered$trans_order, hjust = 0, label = to_plot_ordered$transcript_name), size = 3) +
    theme_bw() + ylab("") + xlab("") +
    theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), 
          axis.text.y=element_blank(), axis.ticks.y=element_blank(), legend.position = "top", 
          plot.title = element_text(hjust = 0.5), plot.margin = margin(0.1,1,0,0.1, "in")) +
    ggtitle(paste0(name, " Junction to Isoform Map (" , to_plot_ordered$strand[1], " strand )")) + 
    coord_cartesian(xlim = c(min_start, max_end), clip = 'off')
  
  # new code to plot leafcutter cluster info underneath isoform level data
  # aggregate isoform information
  text = df %>% separate(col = transcript_name, into = c("name", "transcript")) %>% group_by(cluster.n, start, end) %>% 
    arrange(cluster.n, start, end, transcript) %>%
    mutate(isoforms = paste0(transcript, collapse = ",")) %>%
    select(1:5, junc.usage, isoforms) %>% distinct() %>% ungroup() %>% 
    mutate(text_plot = paste0(junc.counts, " reads (", junc.usage, "%) : ", isoforms))
  
  clusters = unique(df$cluster.n)
  introns = df %>% select(-gene_id, -trans_id, -gene_name, -transcript_name) %>% 
    distinct() %>% arrange(cluster.n, start)
  introns$junc.order = 1:nrow(introns)
  introns %<>% left_join(text)
  p2 = ggplot() + 
    geom_rect(data = introns, mapping = aes(xmin = start, xmax = end, ymin = junc.order - 0.2, ymax = junc.order + 0.2, fill = cluster.n)) + 
    geom_text(data = introns, aes(x = end, y = junc.order, label = text_plot), hjust = 0, size = 3) +
    xlim(min_start, max_end) + theme_bw() + 
    xlab("Hg38 Genomic Position (bp)") + ylab("") + 
    theme(axis.text.y=element_blank(), axis.ticks.y=element_blank(), legend.position = "none", plot.margin = margin(0,1,0,0.1, "in")) +
    coord_cartesian(xlim = c(min_start, max_end))

  # plot dimenstions based on number of isoforms and junctions
  t = (n + nrow(introns))
  h = t/2
  p1_p2 = plot_grid(p1, p2, ncol = 1, align = "v", rel_heights = c(n*0.8, nrow(introns)))
  #ggsave("~/isoviz/plots/rbfox2_isoforms.pdf", width = 8, height = h)
  return(p1_p2)
}

plot_junction_to_isoform(to_plot)
ggsave("~/isoviz/plots/rbfox2_isoforms.pdf", width = 8, height = 8.5)
```


```{r}
# NFYA
to_plot = map_junction("ENSG00000001167.15", cell_type = "A375") 
plot_junction_to_isoform(to_plot)
ggsave("~/isoviz/plots/nfya_isoforms.pdf", width = 8, height = 4)

to_plot = map_junction("ENSG00000001167.15", cell_type = "HEK293") 
plot_junction_to_isoform(to_plot)
# for height, count rows and divide by 2
ggsave("~/isoviz/plots/nfya_isoforms_hek293.pdf", width = 8, height = 2)

to_plot = map_junction("ENSG00000001167.15", cell_type = "hESC") 
plot_junction_to_isoform(to_plot)
ggsave("~/isoviz/plots/nfya_isoforms_hESC.pdf", width = 8, height = 2)

# RBFOX2
to_plot = map_junction("ENSG00000100320", cell_type = "A375") # alt start is missing because it's intron doesnt overlap another and counts are only 8 so included in consitutive either
plot_junction_to_isoform(to_plot)

to_plot = map_junction("ENSG00000100320", cell_type = "HEK293") 
plot_junction_to_isoform(to_plot)
ggsave("~/isoviz/plots/rbfox2_isoforms_hek293.pdf", width = 8, height = 9)

to_plot = map_junction("ENSG00000100320", cell_type = "hESC") 
plot_junction_to_isoform(to_plot)
ggsave("~/isoviz/plots/rbfox2_isoforms_hESC.pdf", width = 8, height = 8.5)

```

Generate a junction file of all possible junctions sequences for Andrew to make predictions
- use gencode psl
- want to make sure to have junc id that will correspond to leafcutter (can merge by sequence at first)
- can make this information into a table
```{r}
load(file = "~/isoviz/data/iso_intron_data.rda")
iso_intron_data %>% group_by(transcript_type) %>% tally()
iso_intron_data %>% group_by(chr) %>% tally()
iso_intron_data %>% filter(is.na(chr))

# filter for protein coding and lncRNAs
iso_intron_pc = iso_intron_data %>% filter(transcript_type == "protein_coding" | transcript_type == "lncRNA")

# remove transcript ids and collapse on junction coords
collapsed_junctions = iso_intron_pc %>% select(-trans_id, -transcript_name, -gene_type, -transcript_type) %>% 
  distinct() %>% select(chr, start = intron_starts, end = intron_ends, gene_id, gene_name, strand) # 281,880 junctions- how many show any uniqueness?





# to address how many annotated isoforms have a truly unique junction
# first filter the genes with more than one transcript
iso_intron_pc %>% select(gene_id, trans_id) %>% distinct() # 85,586 transcripts
n_df = iso_intron_pc %>% select(gene_id, trans_id) %>% distinct() %>% group_by(gene_id) %>% mutate(n_transcripts = n()) %>% ungroup() # 33,413
gene_list = n_df %>% select(-trans_id) %>% distinct() %>% filter(n_transcripts > 1) %>% select(gene_id) # 17,035 genes have more than 1 isoform

iso_pc_df = iso_intron_pc %>% full_join(n_df) %>% filter(gene_id %in% gene_list$gene_id) %>%
  group_by(chr, intron_starts, intron_ends, gene_id, strand, gene_name, n_transcripts) %>% mutate(n_trans_per_junc = n(), commonality = round((n_trans_per_junc/n_transcripts)*100, 0)) %>%
  mutate(junction_category = ifelse(n_trans_per_junc == 1, "fully_unique", ifelse(commonality == 100, "common", "partial_unique"))) %>% ungroup()

# junction level numbers- there are ~50,000 fully unique junctions for pc genes, meaning they belong to a singular isoform
iso_pc_df %>% select(chr, intron_starts, intron_ends, strand, gene_id, gene_name, gene_type, junction_category) %>% distinct() %>% 
  group_by(gene_type, junction_category) %>% tally()

# isoform-level, how many isoforms are uniquely targetable
iso_pc_df %>% filter(junction_category == "fully_unique") %>% select(gene_id, gene_name, trans_id, transcript_name, gene_type) %>% distinct() # 47,657 transcripts are uniquely targetable
iso_pc_df %>% filter(junction_category == "fully_unique") %>% select(gene_id, gene_name, trans_id, transcript_name, gene_type) %>% distinct() %>%
  distinct(gene_name) # 16,801 genes

```














